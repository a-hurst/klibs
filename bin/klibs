#!/usr/bin/env python

col = {"@P": '\033[95m',  # purple
		   "@B": '\033[94m',  # blue
		   "@R": '\033[91m',  # red
		   "@T": '\033[1m',   # teal
		   "@E": '\033[0m'    # return to normal
	}

import argparse
import os
import shutil
from subprocess import Popen, PIPE
import traceback
import imp
import time
import sys
from hashlib import sha1

pylink_install_required = False
klibs_version = "0.9.1.4"

#  todo: add in Ross's april fools idea

def print_warning(exc_type, exc_value, exc_traceback):
	print "\n\033[91m*** Fatal Error: Unable to load klibs ***\033[0m"
	print "\n\033[0mStack Trace (if you don't understand this, skip forward to 'What To Do If KLIBs Wasn't Found'"
	print traceback.print_exception(exc_type, exc_value, exc_traceback,limit=5, file=sys.stdout)
	time.sleep(0.3)
	print "\n\033[1mWhat To Do If KLIBS Wasn't Found: \n\033[0mIf the klibs python module couldn't be located; repair the path to the module or reinstall it."
	print "Perhaps you're thinking \"then what's talking to me right now?!\". Don't worry, neither you nor I have gone mad."
	print "Rather, when you typed 'klibs <name> <path>' you executed a setup script to create a new empty project."
	print "This script is invoked using the word 'klibs' as a convenience but it is *not* a part of the klibs python module"
	print "required to execute a klibs project. This script is found at /usr/local/bin/klibs, whereas klibs must be"
	print "reachable by PYTHONPATH. If you don't know what this means try simply reinstalling. If that doesn't work,"
	print "then you probably need assistance. Go find a nerd!\n"
	print "\t\033[94mMore Information:   \033[0mhttp://kleinlab.psychology.dal.ca/klibs/documentation\033[0m"
	print "\t\033[94mDownload Installer: \033[0mhttp://kleinlab.psychology.dal.ca/klibs/installer.zip\033[0m"
	print "\t\033[94mRepository:         \033[0mhttps://github.com/jmwmulle/klibs\n"
	print "\n... if the links don't work it's because Jon likely only wrote this; try: this.impetus@gmail.com!\n"


def full_trace():
	exception_list = traceback.format_stack()
	exception_list = exception_list[:-2]
	exception_list.extend(traceback.format_tb(sys.exc_info()[2]))
	exception_list.extend(traceback.format_exception_only(sys.exc_info()[0], sys.exc_info()[1]))

	exception_str = "Traceback (most recent call last):\n"
	exception_str += "".join(exception_list)
	# Removing the last \n
	return exception_str[:-1]

def create(name, path):
	# try:
	# 	import klibs
	# except ImportError as e:
	# 	print_warning(*sys.exc_info())
	# Adding author details and loop to confirm before execution, was in a rush,  will return later
	# Basically got stick on feeding raw_input() into arg_parse, seems to take each letter as an argument
	# Update #2:  moved on to using just raw_input() until help with how to do this turns up
	# http://stackoverflow.com/questions/32659345/how-to-use-argparse-during-runtime-to-conditionally-get-further-input
	author_ok = False
	while not author_ok:
		try:
			auth_parse = argparse.ArgumentParser()
			auth_parse.add_argument('name', type=str, nargs=2)
			auth_args = auth_parse.parse_args(raw_input("\n\033[32mProvide your first and last name: \033[0m").split())
			if len(auth_args.name) == 2:  # todo: add a check to ensure names are only letters
				author_ok = True
		except SystemExit as e:
			print "\033[91m\nOk Madonna, take it easy. \033[32mFirst \033[92m*\033[32mand\033[92m*\033[32m last name. Let's try that again--you got this champ...\033[0m"
			return create(name, path)

	source_path = "/usr/local/lib/klibs/template"
	project_path = os.path.join(path, name)

	correct = False
	while not correct:
		print "\033[94m*** \033[95mConfirm Project Details\033[94m ***\033[0m"
		print "\033[96mProject Author: \033[94m{0} {1}\033[0m".format(auth_args.name[0], auth_args.name[1])
		print "\033[96mProject Path: \033[94m{0}\033[0m".format(project_path)
		confirm_parser = argparse.ArgumentParser()
		confirm_parser.add_argument('confirmed',  type=str, choices=['y', 'n', 'yes' ,'no', 'YES', 'NO', 'Yes', 'No', 'q', 'quit', 'Quit', 'QUIT'])
		confirm_args = confirm_parser.parse_args([raw_input("\033[32mIs this correct? Answer with \033[95mY\033[32mes, \033[95mN\033[32mo or \033[95mQ\033[32muit. \033[0m").lower()])
		if confirm_args.confirmed in ["n", "no", "N", "NO"]:
			return create(name, path)
		elif confirm_args.confirmed in ["q", "quit", "QUIT", "Quit"]:
			print "\n\033[32mFine. Be that way. But I think we both know you'll be back.\033[0m"
			exit()
		correct = True
	# try:
	tmp_dir = "klibs_" + sha1(project_path + str(time.time())).hexdigest()
	tmp_path = os.path.join("/","tmp", tmp_dir)
	shutil.copytree(source_path, tmp_path)
	print "\t...Project template files successfully copied to temporary directory."

	# replace generic strings in experiment.py with project author and name
	temp_exp_f = open(os.path.join(tmp_path, "experiment.py"), "rt")
	temp_exp = temp_exp_f.read().replace('PROJECT_NAME', name).replace('EXPERIMENTER_NAME', " ".join(auth_args.name))
	open(os.path.join(tmp_path, "experiment.py"), "w+").write(temp_exp)

	# replace generic file names with project-specific names
	template_files = [['Config', "schema.sql"], ['Config', "factors.csv"], ['Config', "messaging.csv"], ['Config', 'params.py'], [None,".gitignore"]]
	for f in template_files:
		# establish the path to the newly copied template file
		if f[0]:
			template = os.path.join(tmp_path, 'ExpAssets', f[0], 'PROJECT_NAME_{0}'.format(f[1]))
		elif f[1] == ".gitignore":
			template = os.path.join(tmp_path, "gitignore.txt")
		else:
			template = os.path.join(tmp_path, 'ExpAssets', 'PROJECT_NAME_{0}'.format(f[1]))

		# establish the matching path to the would-be project file
		if f[0]:
			project = os.path.join(tmp_path, 'ExpAssets', f[0], '{0}_{1}'.format(name, f[1]))
		elif f[1] == ".gitignore":
			project = os.path.join(tmp_path, '{0}'.format(f[1]))
		else:
			project = os.path.join(tmp_path, 'ExpAssets', '{0}_{1}'.format(name, f[1]))

		shutil.move(template, project)
		temp_project_f = open(project, "rt").read().replace('PROJECT_NAME', name).replace('PROJECT_PATH', path)
		open(project, "w+").write(temp_project_f)
	# versions_temp_dir = os.path.join(project_path, 'ExpAssets', "versions")
	# versions_proj_dir = os.path.join(project_path, 'ExpAssets', ".versions")
	# shutil.move(versions_temp_dir, versions_proj_dir)
		try:
			print "\t...'{0}' successfully configured".format("/".join(f))
		except TypeError:
			print "\t...'{0}' successfully configured".format(f[1])
	shutil.move(tmp_path, path)
	os.rename(os.path.join(path, tmp_dir), os.path.join(path, name))
	print "\033[92m\nProject successfully created at: '\033[94m{0}\033[0m'".format(project_path)
	# except OSError, e:
	# 	if e.errno == 17:
	# 		print "\033[91mError:\033[0m A directory or file already exists at '\033[94m{0}\033[0m'.".format(project_path)
	# 	else:
	# 		raise OSError(e)
	# except Exception as e:
	# 	print "\033[91mError: Project '{0}' not created at {1}.\033[0m".format(name, project_path)
	# 	raise OSError(e)

def update():
	"""
	So this generally works, but with a number of provisions, not the least of which being that the user has to have permissions
	to execute git at /usr/local
	 Generally, this just needs to be a lot more robust.
	 You're using Popen() because it lets you get stdout, whereas subprocess.call() only provides a returncode
	"""
	print "Update isn't currently supported. It's coming in a later update of KLIBs. For now, you can do this manually simply by cloning the git repository (https://www.github.com/jmwmulle/klibs) and re-installing."
	return
	p = Popen(['git', '-C', '/usr/local/klibs/klibs_git', 'pull'], stdin=PIPE, stdout=PIPE, stderr=PIPE)
	output, err = p.communicate()
	print output
	print err


def run(path, screen_size, random_seed, development_mode, no_eyelink, show_debug_pane, verbose):
	import klibs
	from klibs import  P, event_interface
	from klibs.KLGraphics import display_init
	from klibs.KLEyeLink import EyeLinkExt
	from klibs.KLDatabase import Database
	from klibs.KLUtilities import force_quit

	if path[-1] == "/": path = path[:-1]  # strip trailing slash from provided path if needed

	# get project name and set working directory to top of project
	project_name = os.path.split(path)[-1]
	os.chdir(path)

	# set some basic global Params
	P.verbose_mode = verbose
	if not show_debug_pane:
		P.dm_suppress_debug_pane = True
	if random_seed:
		P.random_seed = random_seed
	if development_mode:
		P.development_mode = True
		P.collect_demographics = False

	# get actual current klibs commit & compare value currently in KLParams
	if P.klibs_commit != Popen(['git', 'rev-parse', 'HEAD'], stdout=PIPE, stderr=PIPE).communicate()[0][:-1]:
		pass # todo: warn user

	# set initial param values for project's context
	P.setup(project_name)
	event_interface.import_events()
	# import params defined in project's local params file in ExpAssets/Config
	for k, v in imp.load_source("*", P.params_file_path).__dict__.iteritems():
		setattr(P, k, v)

	# create an EyeLink instance if needed
	if P.eye_tracking:
		eyelink = EyeLinkExt()
		if no_eyelink:
			P.eye_tracker_available = False
		eyelink.dummy_mode = P.eye_tracker_available is False
	else:
		eyelink = False
	# create a Database instance
	klibs.database = Database(project_name)
	# finally, import the project's Experiment class and instantiate
	try:
		experiment_file = imp.load_source(path, "experiment.py")
		experiment = getattr(experiment_file, project_name)
		klibs.experiment = experiment(project_name, eyelink)

		# create a display context if everything's gone well so far
		klibs.experiment.window = display_init(screen_size)
		klibs.experiment.show_logo()
		# off to the races team...
		klibs.experiment.run()
	except SystemExit:
		pass
	except Exception as e:
		print "\n"
		print "".join(traceback.format_exception_only(sys.exc_info()[0], sys.exc_info()[1]) + traceback.format_tb(sys.exc_info()[2]))
		force_quit()


def export(path, multi_file=True, join_tables=None):
	from klibs import P, KLDatabase

	if path[-1] == "/": path = path[:-1]  # strip trailing slash from provided path if needed

	# get project name and set working directory to top of project
	project_name = os.path.split(path)[-1]
	os.chdir(path)

	# set initial param values for project's context
	P.setup(project_name)

	# import params defined in project's local params file in ExpAssets/Config
	for k, v in imp.load_source("*", P.params_file_path).__dict__.iteritems():
		setattr(P, k, v)

	KLDatabase(project_name).export(multi_file, join_tables)


def rebuild_db(path):
	from klibs import P
	from klibs.KLDatabase import Database
	from klibs.KLUtilities import force_quit

	if path[-1] == "/": path = path[:-1]  # strip trailing slash from provided path if needed

	# get project name and set working directory to top of project
	project_name = os.path.split(path)[-1]
	os.chdir(path)

	# set initial param values for project's context
	P.setup(project_name)

	# import params defined in project's local params file in ExpAssets/Config
	for k, v in imp.load_source("*", P.params_file_path).__dict__.iteritems():
		setattr(P, k, v)
	Database(project_name).rebuild()
	force_quit()



def hard_reset(path):
	#todo: require confirmation
	for d in ['Data', 'EDF', '.versions']:
		try:
			shutil.rmtree(os.path.join(path, "ExpAssets", d))
		except OSError:
			pass
	os.makedirs(os.path.join(path, "ExpAssets", "Data", "incomplete"))
	os.makedirs(os.path.join(path, "ExpAssets", "EDF", "incomplete"))
	os.mkdir(os.path.join(path, "ExpAssets", ".versions"))
	rebuild_db(path)


parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers(title='subcommands',
								   description='Valid arguments: create, update, run, export, hard-reset, db-rebuild',
								   help='additional help')

create_parser = subparsers.add_parser('create')
create_parser.add_argument('name', type=str)
create_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
						   help='Path where new project should be created; if empty, project will attempt to be created in current working directory.')
create_parser.set_defaults(func=create)

update_parser = subparsers.add_parser('update')
update_parser.set_defaults(func=update)

rebuild_parser = subparsers.add_parser('db-rebuild')
rebuild_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
							help='Path to directory containing the KLIBs project. Parent folder must be the project name.')
rebuild_parser.set_defaults(func=rebuild_db)

rebuild_parser = subparsers.add_parser('hard-reset')
rebuild_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
							help='Path to directory containing the KLIBs project. Parent folder must be the project name.')
rebuild_parser.set_defaults(func=hard_reset)

run_parser = subparsers.add_parser('run')
run_parser.add_argument('screen_size', type=int,
						help='The diagonal size of the screen in inches on which the experiment is being run. This is used to calculate degrees of visual angle.')
run_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
						help='Path to directory containing the KLIBs project. Parent folder must be the project name.')
run_parser.add_argument('-rs', '--random_seed', type=int,
						help="Providing a random seed will allow an experiment to continue from it's previously completed state.")
run_parser.add_argument('-d', '--development_mode', action="store_true",
						help="Development mode turns off demographics collection and turns on several debugging features.")
run_parser.add_argument('-ELx', '--no_eyelink', action="store_false",
						help="Signals the absence of a connected eyelink unit. Does nothing for non-eyetracking experiments.")
run_parser.add_argument('-dbg', '--show_debug_pane', action="store_true",
						help="Debug log will be blit to translucent panel on screen in real time.")
# todo: verbose mode should accept a value, and then logging should be incrementally verbose
run_parser.add_argument('-v', '--verbose', action="store_true",
						help="EventsInterface will syndicate EyeLink, log & LabJack messages to terminal.")
run_parser.set_defaults(func=run)

export_parser = subparsers.add_parser('export')
export_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
						   help='Path to directory containing the KLIBs project. Parent folder must be the project name.')
export_parser.add_argument('-mf', '--multi_file', action="store_false",
						   help='Export participants as a single file or multiple files. Default is multi-file. ')
export_parser.add_argument('-j', '--join_tables', default=[], nargs="*", type=str,
						   help="Additional tables to be joined to the data output. Only 'participant' and 'data' tables are exported by default.")
export_parser.set_defaults(func=export)

args = vars(parser.parse_args())


arg_dict = {}
for key in args:
	if key != "func": arg_dict[key] = args[key]

args["func"](**arg_dict)
