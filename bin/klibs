#!/usr/bin/env python

import argparse
import os
from os.path import join
from os import makedirs
import shutil
import traceback
import imp
import time
import sys
import pip

from random import choice
from hashlib import sha1
from pkg_resources import resource_filename, resource_string
from klibs.KLExceptions import DatabaseException
from klibs.KLUtilities import hide_mouse_cursor
from klibs.KLUtilities import colored_stdout as cso

klibs_version = "0.6.0"

#  todo: add in Ross's april fools idea

def print_warning(exc_type, exc_value, exc_traceback):
	cso("\n<red>*** Fatal Error: Unable to load KLibs ***</red>")
	cso("\nStack Trace (if you don't understand this, skip forward to 'What To Do If KLibs Wasn't Found'")
	cso(traceback.print_exception(exc_type, exc_value, exc_traceback,limit=5, file=sys.stdout))
	time.sleep(0.3)
	# this should probably be rewritten/updated a bit more
	cso("\n<teal>What To Do If KLIBS Wasn't Found: \nIf the KLibs python module couldn't be located; repair the path to the module or reinstall it.</teal>")
	cso("Perhaps you're thinking \"then what's talking to me right now?!\". Don't worry, neither you nor I have gone mad.")
	cso("Rather, when you typed 'klibs <name> <path>' you executed a setup script to create a new empty project.")
	cso("This script is invoked using the word 'klibs' as a convenience but it is *not* a part of the klibs python module")
	cso("required to execute a klibs project. This script is found at /usr/local/bin/klibs, whereas klibs must be")
	cso("reachable by PYTHONPATH. If you don't know what this means try simply reinstalling. If that doesn't work,")
	cso("then you probably need assistance. Go find a nerd!\n")
	cso("\t<blue>More Information:</blue>   http://kleinlab.psychology.dal.ca/klibs/documentation")
	cso("\t<blue>Repository:</blue>         https://github.com/a-hurst/klibs\n")


def full_trace():
	exception_list = traceback.format_stack()
	exception_list = exception_list[:-2]
	exception_list.extend(traceback.format_tb(sys.exc_info()[2]))
	exception_list.extend(traceback.format_exception_only(sys.exc_info()[0], sys.exc_info()[1]))

	exception_str = "Traceback (most recent call last):\n"
	exception_str += "".join(exception_list)

	# Removing the last \n
	return exception_str[:-1]


def create(name, path):
	split_test = os.path.split(name)
	if len(split_test[0]):
		path, name = split_test

	# Adding author details and loop to confirm before execution, was in a rush,  will return later
	# Basically got stick on feeding raw_input() into arg_parse, seems to take each letter as an argument
	# Update #2:  moved on to using just raw_input() until help with how to do this turns up
	# http://stackoverflow.com/questions/32659345/how-to-use-argparse-during-runtime-to-conditionally-get-further-input
	author_ok = False
	while not author_ok:
		try:
			auth_parse = argparse.ArgumentParser()
			auth_parse.add_argument('name', type=str, nargs=2)
			auth_args = auth_parse.parse_args(raw_input(cso("\n<green_d>Provide your first and last name: </green_d>", False)).split())
			if len(auth_args.name) == 2:  # todo: add a check to ensure names are only letters
				author_ok = True
		except SystemExit:
			one_name_peeps = ["Madonna", "Prince", "Cher", "Bono", "Sting"]
			cso("<red>\nOk {0}, take it easy.</red> <green_d>First</green_d> <cyan>*and*</cyan> <green_d>last name. "\
				"Let's try that again--you got this champ...</green_d>".format(choice(one_name_peeps)))
			return create(name, path)

	source_path = resource_filename('klibs', 'resources/template')
	project_path = join(path, name)

	correct = False
	while not correct:
		cso("<blue>***</blue> <purple>Confirm Project Details</purple> <blue>***</blue>")
		cso("<cyan>Project Author:</cyan> <blue>{0} {1}</blue>", args=[auth_args.name[0], auth_args.name[1]])
		cso("<cyan>Project Path:</cyan> <blue>{0}</blue>", args=[project_path])
		def get_response():
			confirm_parser = argparse.ArgumentParser()
			confirm_parser.add_argument('confirmed',  type=str, choices=['y', 'n', 'q'])
			query = cso("<green_d>Is this correct? Answer with</green_d> <purple>Y</purple>" \
						"<green_d>es,</green_d> <purple>N</purple><green_d>o or</green_d> " \
						"<purple>Q</purple><green_d>uit.</green_d>", False))
			confirm_args = confirm_parser.parse_args([raw_input(query)[0].lower()])
			return confirm_args.confirmed
		response = get_response()
		if response == "n":
			return create(name, path)
		elif response == "q":
			cso("\n<green_d>Fine. Be that way. But I think we both know you'll be back.</green_d>")
			exit()
		elif response == "y":
			correct = True
		else:
			cso("<green_d>Pardon? I didn't catch that.</green_d>")

	tmp_dir = "klibs_" + sha1(project_path + str(time.time())).hexdigest()
	tmp_path = join("/","tmp", tmp_dir)

	# create project directories
	dir_structure = {"ExpAssets": {
						".versions": None,
						"Config": None,
						"Resources": {"code": None, "font": None,"image": None},
						"Local": {"logs":None},
						"Data": {"incomplete":None},
						"EDF": {"incomplete": None} }
					}

	def build_directory_structure(dir_map, parents=[]):
		if dir_map is None:
			return
		parent_path = os.path.join(*parents) if len(parents) else ""

		for d in dir_map:
			dir_full_path = join(tmp_path, parent_path, d)
			subdirs = dir_map[d]
			try:
				makedirs(dir_full_path)
			except OSError as e:
				cso("failed")
				cso(dir_map, parents)
				exit()
			new_parents = [p for p in parents]
			new_parents.append(d)
			build_directory_structure(subdirs, new_parents)

	build_directory_structure(dir_structure)
	cso("\t<cyan>...Project template files successfully created in temporary project directory.</cyan>")

	# replace generic file names with project-specific names
	template_files = [("schema.sql", ["ExpAssets", "Config"]),
					  ("independent_variables.py", ["ExpAssets", "Config"]),
					  ("messaging.csv", ["ExpAssets", "Config"]),
					  ("params.py", ["ExpAssets", "Config"]),
					  ("user_queries.json", ["ExpAssets", "Config"]),
					  ("experiment.py", []),
					  (".gitignore", [])]

	for tf in template_files:
		target_f_name = tf[0] if tf[0] in [".gitignore", "experiment.py"] else "{0}_{1}".format(name, tf[0])
		template_f_path = join(source_path, tf[0] if tf[0] != ".gitignore" else "gitignore.txt")
		try:
			project_f_path = join(tmp_path, join(*tf[1]), target_f_name)
		except TypeError:
			project_f_path = join(tmp_path, target_f_name)
		project_f_contents = open(template_f_path, "rt").read()
		project_f_contents = project_f_contents.replace('PROJECT_NAME', name).replace('PROJECT_PATH', path)
		project_f_contents = project_f_contents.replace('EXPERIMENTER_NAME', " ".join(auth_args.name))
		project_f = open(project_f_path, "w+")
		project_f.write(project_f_contents)
		project_f.close()
		try:
			cso("\t<cyan>...'{0}' successfully created in temporary project directory.</cyan>".format(join(join(*tf[1]), target_f_name)))
		except TypeError:
			cso("\t<cyan>...'{0}' successfully created in temporary project directory</cyan>".format(target_f_name))

	shutil.move(tmp_path, path)
	os.rename(join(path, tmp_dir), join(path, name))
	cso("<green_d>\nProject successfully created at:</green_d> '<blue>{0}</blue>'".format(project_path))


def update(branch='default'):
	#TODO: This should really be able to compare the version/commit/origin of the current KLibs
	#install and the one about to be installed to make sure you can't unintentionally overwrite
	#a newer local version or install from a different branch.
	git_repo_short = 'github.com/a-hurst'
	git_repo = 'https://{0}/klibs.git'.format(git_repo_short)
	if branch != 'default':
		git_repo += "@{0}".format(branch)
	
	update_cmd = 'install -U git+{0}#egg=klibs --no-deps'.format(git_repo)
	update_prompt = cso("\n<green_d>Updating will replace the current install of KLibs with" \
	" the most recent commit of the </green_d><purple>{0}</purple><green_d> branch of " \
	"</green_d><purple>'{1}'</purple><green_d>. Are you sure you want to continue?" \
	" (Y/N): </green_d>".format(branch,git_repo_short), False)
	if raw_input(update_prompt).lower() == "y":
		print " "
		cso("<green_d>Updating klibs to latest commit from {0}...</green_d>".format(git_repo_short))
		try:
			pip.main(update_cmd.split(' '))
		except OSError:
			cso("<red>Root permissions required to reinstall klibs.</red>")
			exit()
	else:
		print " "
		exit()


def run(path, screen_size, random_seed, development_mode, no_eyelink, show_debug_pane, verbose):
	from logging import INFO, DEBUG, WARNING, ERROR, CRITICAL
	from klibs import  P
	from klibs.KLGraphics import display_init
	from klibs import KLEyeLink
	from klibs.KLDatabase import Database
	from klibs.KLUtilities import force_quit
	from klibs import env
	from klibs.KLEventInterface import EventManager
	from klibs.KLTime import TimeKeeper
	from klibs.KLText import TextManager
	from klibs.KLResponseCollectors import ResponseCollector
	from klibs.KLCommunication import init_messaging, collect_demographics
	import logging as lg

	if path[-1] == "/": path = path[:-1]  # strip trailing slash from provided path if needed

	# get project name and set working directory to top of project
	project_name = os.path.split(path)[-1]
	os.chdir(path)
	
	# check if the project directory contains an experiment.py file. If it doesn't,
	# it probably isn't the parent directory of a KLibs project and we should quit.
	if not os.path.isfile('experiment.py'):
		cso("\n<red>Error: no 'experiment.py' file was found in the project directory.\n" \
			"Please make sure you are in a valid project folder and try 'klibs run' again.</red>\n")
		exit()

	# create any missing project directories
	dir_structure = {"ExpAssets": {
						".versions": None,
						"Config": None,
						"Resources": {"code": None, "font": None, "image": None},
						"Local": {"logs": None},
						"Data": {"incomplete": None},
						"EDF": {"incomplete": None}}
					}

	def ensure_directory_structure(dir_map, parents=[], create_missing=False):
		missing_dirs = []
		if dir_map is None:
			return missing_dirs
		parent_path = os.path.join(*parents) if len(parents) else ""

		for d in dir_map:
			dir_full_path = join(path, parent_path, d)
			subdirs = dir_map[d]
			if not os.path.exists(dir_full_path):
				if not create_missing:
					missing_dirs.append(dir_full_path)
				else:
					try:
						makedirs(dir_full_path)
					except OSError as e:
						cso("failed")
						cso(dir_map, parents)
						exit()

			new_parents = [p for p in parents]
			new_parents.append(d)
			missing_dirs += ensure_directory_structure(subdirs, new_parents, create_missing)
		return missing_dirs

	missing_dirs = ensure_directory_structure(dir_structure)

	if len(missing_dirs):
		def get_response(first_call=True):
			if first_call:
				cso("<red>Some expected or required directories for this project appear to be missing.</red>")
			next_action = argparse.ArgumentParser()
			next_action.add_argument('action',  type=str, choices=['c', 'r'])
			query = cso("<green_d>You can</green_d> <purple>(c)</purple><green_d>reate them" \
						" automatically or view a <purple>(r)</purple><green_d>eport on the" \
						" missing directories.</green_d>", False)
			action = next_action.parse_args([raw_input(query).lower()[0]])
			if action.action == "r":
				cso("<green_d>The following expected directories were not found:</green_d>")
				for md in missing_dirs:
					cso("\t <purple>{0}</purple>".format(md))
				return get_response(False)
			elif action.action == "c":
				ensure_directory_structure(dir_structure, create_missing=True)
		get_response()
	# set initial param values for project's context
	P.setup(project_name)

	# import params defined in project's local params file in ExpAssets/Config
	for k, v in imp.load_source("*", P.params_file_path).__dict__.iteritems():
		setattr(P, k, v)

	# if a local params file exists, do the same:
	if os.path.exists(P.params_local_file_path) and not P.dm_ignore_local_overrides:
		for k, v in imp.load_source("*", P.params_local_file_path).__dict__.iteritems():
			setattr(P, k, v)

	# logging and debugging will go here one day....
	# klog_config = {}
	# lg.basicConfig(filename='example.log', level=DEBUG)

	# set some basic global Params
	P.verbose_mode = verbose
	if not show_debug_pane:
		P.dm_suppress_debug_pane = True
	if random_seed:
		P.random_seed = random_seed
	if development_mode:
		P.development_mode = True
		P.collect_demographics = False
	P.klibs_commit = resource_string('klibs', 'resources/current_commit.txt')
	#TODO: check if current commit matches experiment.py and warn user if not

	# create runtime environment
	env.evm = EventManager()
	if P.eye_tracking:
		if no_eyelink is False:  #
			PYLINK_AVAILABLE = False
			P.eye_tracker_available = False
		reload(KLEyeLink)
		env.el = KLEyeLink.EyeLinkExt()

	if not P.labjack_available:
		P.labjacking = False

	env.txtm = TextManager()
	env.tk = TimeKeeper()
	try:
		env.db = Database(project_name)
	except DatabaseException as e:
		if e.message == "Quitting.":
			env.evm.terminate()
			exit()
		else:
			cso("<red>Unable to load database.</red>")
			force_quit()
	env.evm.import_events()
	env.rc = ResponseCollector()
	# finally, import the project's Experiment class and instantiate
	try:
		experiment_file = imp.load_source(path, "experiment.py")
		experiment = getattr(experiment_file, project_name)
		env.exp = experiment(project_name)

		# create a display context if everything's gone well so far
		env.exp.window = display_init(screen_size)

		env.exp.show_logo()

		# create basic text styles and auto-render block-break messages if need configured to do so
		init_messaging()

		# create an anonymous user if not collecting demographic information
		if not P.manual_demographics_collection:
			collect_demographics(not P.collect_demographics or P.development_mode)

		# off to the races team...
		env.exp.run()
	except SystemExit:
		pass
	except Exception as e:
		print "\n"
		print "".join(traceback.format_exception_only(sys.exc_info()[0], sys.exc_info()[1]) + traceback.format_tb(sys.exc_info()[2]))
		force_quit()


def export(path, combined=False, join_tables=None):
	from klibs import P
	from klibs.KLDatabase import Database

	if path[-1] == "/": path = path[:-1]  # strip trailing slash from provided path if needed

	# get project name and set working directory to top of project
	project_name = os.path.split(path)[-1]
	os.chdir(path)

	# set initial param values for project's context
	P.setup(project_name)

	# import params defined in project's local params file in ExpAssets/Config
	for k, v in imp.load_source("*", P.params_file_path).__dict__.iteritems():
		setattr(P, k, v)
	multi_file = combined != True
	Database(project_name).export(multi_file, join_tables)


def rebuild_db(path):
	from klibs import P
	from klibs.KLDatabase import Database
	from klibs.KLUtilities import force_quit

	if path[-1] == "/": path = path[:-1]  # strip trailing slash from provided path if needed

	# get project name and set working directory to top of project
	project_name = os.path.split(path)[-1]
	os.chdir(path)

	# set initial param values for project's context
	P.setup(project_name)

	# import params defined in project's local params file in ExpAssets/Config
	for k, v in imp.load_source("*", P.params_file_path).__dict__.iteritems():
		setattr(P, k, v)
	Database(project_name).rebuild()
	force_quit()


# def rename(path): todo: write this, it's irritatingly complex but also super necessary



def hard_reset(path):
	from klibs.KLUtilities import iterable
	reset_prompt = cso("\n<red>Warning: doing a hard reset will delete all collected data", \
	" all logs, all copies of experiment.py and Config files in the .versions folder" \
	" that previous participants were run with, and reset the project's database." \
	" Are you sure you want to continue?</red> (Y/N): ")
	if raw_input(reset_prompt).lower() == "y":
		for d in ['Data', 'EDF', '.versions', ('Local', 'logs')]:
			if iterable(d):
				d = join(*d)
			try:
				shutil.rmtree(join(path, "ExpAssets", d))
			except OSError:
				pass
		os.makedirs(join(path, "ExpAssets", "Data", "incomplete"))
		os.makedirs(join(path, "ExpAssets", "EDF", "incomplete"))
		os.mkdir(join(path, "ExpAssets", "Local", "logs"))
		os.mkdir(join(path, "ExpAssets", ".versions"))
		rebuild_db(path)
	print " "


# the part of the script that gets run when klibs is invoked from cli
if __name__ == '__main__': 

	sys.dont_write_bytecode = True # suppress creation of useless .pyc files

	parser = argparse.ArgumentParser()
	subparsers = parser.add_subparsers(
		title='subcommands',
		description='Valid arguments: create, update, run, export, hard-reset, db-rebuild',
		help='additional help'
	)

	create_parser = subparsers.add_parser('create')
	create_parser.add_argument('name', type=str)
	create_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
		help=("Path where new project should be created; if empty, project will attempt "
		"to be created in current working directory.")
	)
	create_parser.set_defaults(func=create)

	update_parser = subparsers.add_parser('update')
	update_parser.add_argument('branch', type=str)
	update_parser.set_defaults(func=update)

	rebuild_parser = subparsers.add_parser('db-rebuild')
	rebuild_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
		help=("Path to directory containing the KLIBs project. "
		"Parent folder must be the project name.")
	)
	rebuild_parser.set_defaults(func=rebuild_db)

	rebuild_parser = subparsers.add_parser('hard-reset')
	rebuild_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
		help=("Path to directory containing the KLIBs project. "
		"Parent folder must be the project name.")
	)
	rebuild_parser.set_defaults(func=hard_reset)

	run_parser = subparsers.add_parser('run')
	run_parser.add_argument('screen_size', type=int,
		help=("The diagonal size of the screen in inches on which the experiment is being run. "
		"This is used to calculate degrees of visual angle.")
	)
	run_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
		help=("Path to directory containing the KLIBs project. "
		"Parent folder must be the project name.")
	)
	run_parser.add_argument('-rs', '--random_seed', type=int,
		help=("Providing a random seed will allow an experiment to continue from its "
		"previously completed state.")
	)
	run_parser.add_argument('-d', '--development_mode', action="store_true",
		help=("Development mode turns off demographics collection and turns on several "
		"debugging features.")
	)
	run_parser.add_argument('-ELx', '--no_eyelink', action="store_false",
		help=("Signals the absence of a connected EyeLink unit. "
		"Does nothing for non-eyetracking experiments.")
	)
	run_parser.add_argument('-dbg', '--show_debug_pane', action="store_true",
		help="Debug log will be blit to translucent panel on screen in real time."
	)
	# todo: verbose mode should accept a value, and then logging should be incrementally verbose
	run_parser.add_argument('-v', '--verbose', action="store_true",
		help="EventsInterface will syndicate EyeLink, LabJack & log messages to terminal."
	)
	run_parser.set_defaults(func=run)

	export_parser = subparsers.add_parser('export')
	export_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
		help=("Path to directory containing the KLIBs project. "
		"Parent folder must be the project name.")
	)
	export_parser.add_argument('-c', '--combined', action="store_true",
		help=("Export data to a single file instead of individual files for each participant. "
		"Default is individual files.")
	)
	export_parser.add_argument('-j', '--join_tables', default=[], nargs="*", type=str,
		help=("Additional tables to be joined to the data output. "
		"Only 'participant' and 'data' tables are exported by default.")
	)
	export_parser.set_defaults(func=export)

	args = vars(parser.parse_args())


	arg_dict = {}
	for key in args:
		if key != "func": arg_dict[key] = args[key]

	args["func"](**arg_dict)
