#!/usr/bin/env python

import argparse
import os
from os.path import join
from os import makedirs
import shutil
from subprocess import Popen, PIPE
import traceback
import imp
import time
import sys
import errno
from random import choice
from hashlib import sha1
from klibs.KLExceptions import DatabaseException
from klibs.KLUtilities import colored_stdout as cso
pylink_install_required = False
klibs_version = "0.9.1.4"

#  todo: add in Ross's april fools idea

def print_warning(exc_type, exc_value, exc_traceback):
	cso("\n<red>*** Fatal Error: Unable to load klibs ***</red>")
	cso("\nStack Trace (if you don't understand this, skip forward to 'What To Do If KLIBs Wasn't Found'")
	cso(traceback.print_exception(exc_type, exc_value, exc_traceback,limit=5, file=sys.stdout))
	time.sleep(0.3)
	cso("\n<teal>What To Do If KLIBS Wasn't Found: \nIf the klibs python module couldn't be located; repair the path to the module or reinstall it.</teal>")
	cso("Perhaps you're thinking \"then what's talking to me right now?!\". Don't worry, neither you nor I have gone mad.")
	cso("Rather, when you typed 'klibs <name> <path>' you executed a setup script to create a new empty project.")
	cso("This script is invoked using the word 'klibs' as a convenience but it is *not* a part of the klibs python module")
	cso("required to execute a klibs project. This script is found at /usr/local/bin/klibs, whereas klibs must be")
	cso("reachable by PYTHONPATH. If you don't know what this means try simply reinstalling. If that doesn't work,")
	cso("then you probably need assistance. Go find a nerd!\n")
	cso("\t<blue>More Information:</blue>   http://kleinlab.psychology.dal.ca/klibs/documentation")
	cso("\t<blue>Download Installer:</blue> http://kleinlab.psychology.dal.ca/klibs/installer.zip")
	cso("\t<blue>Repository:</blue>        https://github.com/jmwmulle/klibs\n")
	cso("\n... if the links don't work it's because Jon likely only wrote this; try: this.impetus@gmail.com!\n")


def full_trace():
	exception_list = traceback.format_stack()
	exception_list = exception_list[:-2]
	exception_list.extend(traceback.format_tb(sys.exc_info()[2]))
	exception_list.extend(traceback.format_exception_only(sys.exc_info()[0], sys.exc_info()[1]))

	exception_str = "Traceback (most recent call last):\n"
	exception_str += "".join(exception_list)

	# Removing the last \n
	return exception_str[:-1]


def create(name, path):
	split_test = os.path.split(name)
	if len(split_test[0]):
		path, name = split_test

	# Adding author details and loop to confirm before execution, was in a rush,  will return later
	# Basically got stick on feeding raw_input() into arg_parse, seems to take each letter as an argument
	# Update #2:  moved on to using just raw_input() until help with how to do this turns up
	# http://stackoverflow.com/questions/32659345/how-to-use-argparse-during-runtime-to-conditionally-get-further-input
	author_ok = False
	while not author_ok:
		try:
			auth_parse = argparse.ArgumentParser()
			auth_parse.add_argument('name', type=str, nargs=2)
			auth_args = auth_parse.parse_args(raw_input(cso("\n<green_d>Provide your first and last name: </green_d>", False)).split())
			if len(auth_args.name) == 2:  # todo: add a check to ensure names are only letters
				author_ok = True
		except SystemExit:
			one_name_peeps = ["Madonna", "Prince", "Cher", "Bono", "Sting"]
			cso("<red>\nOk {0}, take it easy.</red> <green_d>First</green_d> <cyan>*and*</cyan> <green_d>last name. "\
				"Let's try that again--you got this champ...</green_d>".format(choice(one_name_peeps)))
			return create(name, path)

	source_path = "/usr/local/lib/klibs/template"
	project_path = join(path, name)

	correct = False
	while not correct:
		cso("<blue>***</blue> <purple>Confirm Project Details</purple> <blue>***</blue>")
		cso("<cyan>Project Author:</cyan> <blue>{0} {1}</blue>", args=[auth_args.name[0], auth_args.name[1]])
		cso("<cyan>Project Path:</cyan> <blue>{0}</blue>", args=[project_path])
		def get_response():
			confirm_parser = argparse.ArgumentParser()
			confirm_parser.add_argument('confirmed',  type=str, choices=['y', 'n', 'q'])
			confirm_args = confirm_parser.parse_args([raw_input(cso("<green_d>Is this correct? Answer with</green_d> <purple>Y</purple>" \
																	"<green_d>es,</green_d> <purple>N</purple><green_d>o or</green_d> " \
																	"<purple>Q</purple><green_d>uit.</green_d>", False))[0].lower()])
			return confirm_args.confirmed
		response = get_response()
		if response == "n":
			return create(name, path)
		elif response == "q":
			cso("\n<green_d>Fine. Be that way. But I think we both know you'll be back.</green_d>")
			exit()
		elif response == "y":
			correct = True
		else:
			cso("<green_d>Pardon? I didn't catch that.</green_d>")

	tmp_dir = "klibs_" + sha1(project_path + str(time.time())).hexdigest()
	tmp_path = join("/","tmp", tmp_dir)

	# create project directories
	dir_structure = {"ExpAssets": {
						".versions": None,
						"Config": None,
						"Resources": {"code": None, "font": None,"image": None},
						"Local": {"logs":None},
						"Data": {"incomplete":None},
						"EDF": {"incomplete": None} }
					}

	def build_directory_structure(dir_map, parents=[]):
		if dir_map is None:
			return
		parent_path = os.path.join(*parents) if len(parents) else ""

		for d in dir_map:
			dir_full_path = join(tmp_path, parent_path, d)
			subdirs = dir_map[d]
			try:
				makedirs(dir_full_path)
			except OSError as e:
				cso("failed")
				cso(dir_map, parents)
				exit()
			new_parents = [p for p in parents]
			new_parents.append(d)
			build_directory_structure(subdirs, new_parents)

	build_directory_structure(dir_structure)
	cso("\t<cyan>...Project template files successfully created in temporary project directory.</cyan>")

	# replace generic file names with project-specific names
	template_files = [("schema.sql", ["ExpAssets", "Config"]),
					  ("factors.csv", ["ExpAssets", "Config"]),
					  ("messaging.csv", ["ExpAssets", "Config"]),
					  ("params.py", ["ExpAssets", "Config"]),
					  ("experiment.py", []),
					  (".gitignore", [])]

	for tf in template_files:
		target_f_name = tf[0] if tf[0] in [".gitignore", "experiment.py"] else "{0}_{1}".format(name, tf[0])
		template_f_path = join(source_path, tf[0] if tf[0] != ".gitignore" else "gitignore.txt")
		try:
			project_f_path = join(tmp_path, join(*tf[1]), target_f_name)
		except TypeError:
			project_f_path = join(tmp_path, target_f_name)
		project_f_contents = open(template_f_path, "rt").read()
		project_f_contents = project_f_contents.replace('PROJECT_NAME', name).replace('PROJECT_PATH', path)
		project_f_contents = project_f_contents.replace('EXPERIMENTER_NAME', " ".join(auth_args.name))
		project_f = open(project_f_path, "w+")
		project_f.write(project_f_contents)
		project_f.close()
		try:
			cso("\t<cyan>...'{0}' successfully created in temporary project directory.</cyan>".format(join(join(*tf[1]), target_f_name)))
		except TypeError:
			cso("\t<cyan>...'{0}' successfully created in temporary project directory</cyan>".format(target_f_name))

	shutil.move(tmp_path, path)
	os.rename(join(path, tmp_dir), join(path, name))
	cso("<green_d>\nProject successfully created at:</green_d> '<blue>{0}</blue>'".format(project_path))


def update():
	"""
	So this generally works, but with a number of provisions, not the least of which being that the user has to have permissions
	to execute git at /usr/local
	 Generally, this just needs to be a lot more robust.
	 You're using Popen() because it lets you get stdout, whereas subprocess.call() only provides a returncode
	"""
	# todo: look for older versions of klibs from before KLDraw was a submodule and remove it else KLDraw won't import properly
	# cso("Update isn't currently supported. It's coming in a later update of KLIBs. For now, you can do this manually simply by cloning the git repository (https://www.github.com/jmwmulle/klibs) and re-installing.")
	# return
	from klibs import P
	commit = None
	try:
		p = Popen(['git', '-C', '/usr/local/lib/klibs/klibs_git', 'pull'], stdin=PIPE, stdout=PIPE, stderr=PIPE)
		output, err = p.communicate()
		if len(err):
			raise IOError(err)
		if len(output):
			cso(output)
			p = Popen(['git', 'rev-parse', 'HEAD'], stdout=PIPE, stderr=PIPE)
			commit = p.communicate()[0][:-1]
	except IOError as e:
		print e
		exit()

	if commit != P.klibs_commit:
		try:
			os.chdir("/usr/local/lib/klibs/klibs_git/")
			p = Popen(['sudo', 'python', 'setup.py', 'install'], stdin=PIPE, stdout=PIPE, stderr=PIPE)
			output, err = p.communicate()
			if len(err):
				raise IOError(err)
			if len(output):
				cso(output)
		except IOError as e:
			print e
			cso("<red>Root permissions required to reinstall klibs.</red>")
			exit()


def run(path, screen_size, random_seed, development_mode, no_eyelink, show_debug_pane, verbose):
	from logging import INFO, DEBUG, WARNING, ERROR, CRITICAL
	from klibs import  P
	from klibs.KLGraphics import display_init
	from klibs import KLEyeLink
	from klibs.KLDatabase import Database
	from klibs.KLUtilities import force_quit
	from klibs import env
	from klibs.KLEventInterface import EventManager
	from klibs.KLTime import TimeKeeper
	from klibs.KLText import TextManager
	from klibs.KLResponseCollectors import ResponseCollector
	import logging as lg

	if path[-1] == "/": path = path[:-1]  # strip trailing slash from provided path if needed

	# get project name and set working directory to top of project
	project_name = os.path.split(path)[-1]
	os.chdir(path)

	# create any missing project directories
	dir_structure = {"ExpAssets": {
						".versions": None,
						"Config": None,
						"Resources": {"code": None, "font": None, "image": None},
						"Local": {"logs": None},
						"Data": {"incomplete": None},
						"EDF": {"incomplete": None}}
					}

	def ensure_directory_structure(dir_map, parents=[], create_missing=False):
		missing_dirs = []
		if dir_map is None:
			return missing_dirs
		parent_path = os.path.join(*parents) if len(parents) else ""

		for d in dir_map:
			dir_full_path = join(path, parent_path, d)
			subdirs = dir_map[d]
			if not os.path.exists(dir_full_path):
				if not create_missing:
					missing_dirs.append(dir_full_path)
				else:
					try:
						makedirs(dir_full_path)
					except OSError as e:
						cso("failed")
						cso(dir_map, parents)
						exit()

			new_parents = [p for p in parents]
			new_parents.append(d)
			missing_dirs += ensure_directory_structure(subdirs, new_parents, create_missing)
		return missing_dirs

	missing_dirs = ensure_directory_structure(dir_structure)

	if len(missing_dirs):
		def get_response(first_call=True):
			if first_call:
				cso("<red>Some expected or required directories for this project appear to be missing.</red>")
			next_action = argparse.ArgumentParser()
			next_action.add_argument('action',  type=str, choices=['c', 'r'])
			action = next_action.parse_args([raw_input(cso("<green_d>You can</green_d> <purple>(c)</purple><green_d>reate them" \
													   " automatically or view a <purple>(r)</purple><green_d>eport on the" \
													   " missing directories.</green_d>", False)).lower()[0]])
			if action.action == "r":
				cso("<green_d>The following expected directories were not found:</green_d>")
				for md in missing_dirs:
					cso("\t <purple>{0}</purple>".format(md))
				return get_response(False)
			elif action.action == "c":
				ensure_directory_structure(dir_structure, create_missing=True)
		get_response()
	# set initial param values for project's context
	P.setup(project_name)

	# import params defined in project's local params file in ExpAssets/Config
	for k, v in imp.load_source("*", P.params_file_path).__dict__.iteritems():
		setattr(P, k, v)
	klog_config = {}
	# if P.
	lg.basicConfig(filename='example.log', level=DEBUG)
	# set some basic global Params
	P.verbose_mode = verbose
	if not show_debug_pane:
		P.dm_suppress_debug_pane = True
	if random_seed:
		P.random_seed = random_seed
	if development_mode:
		P.development_mode = True
		P.collect_demographics = False

	# get actual current klibs commit & compare value currently in KLParams
	P.klibs_commit = open("/usr/local/lib/klibs/current_commit.txt").read()
	# if P.klibs_commit != Popen(['git', 'rev-parse', 'HEAD'], stdout=PIPE, stderr=PIPE).communicate()[0][:-1]:
	# 	pass # todo: warn user

	# create runtime environment
	env.evm = EventManager()
	if P.eye_tracking:
		if no_eyelink is False:  #
			PYLINK_AVAILABLE = False
			P.eye_tracker_available = False
		reload(KLEyeLink)
		env.el = KLEyeLink.EyeLinkExt()
			
	env.txtm = TextManager()
	env.tk = TimeKeeper()
	try:
		env.db = Database(project_name)
	except DatabaseException as e:
		if e.message == "Quitting.":
			env.evm.terminate()
			exit()
		else:
			cso("<red>Unable to load database.</red>")
			force_quit()
	env.evm.import_events()
	env.rc = ResponseCollector()

	# finally, import the project's Experiment class and instantiate
	try:
		experiment_file = imp.load_source(path, "experiment.py")
		experiment = getattr(experiment_file, project_name)
		env.exp = experiment(project_name)

		# create a display context if everything's gone well so far
		env.exp.window = display_init(screen_size)
		env.exp.show_logo()

		# off to the races team...
		env.exp.run()
	except SystemExit:
		pass
	except Exception as e:
		print "\n"
		print "".join(traceback.format_exception_only(sys.exc_info()[0], sys.exc_info()[1]) + traceback.format_tb(sys.exc_info()[2]))
		force_quit()


def export(path, multi_file=True, join_tables=None):
	from klibs import P, KLDatabase

	if path[-1] == "/": path = path[:-1]  # strip trailing slash from provided path if needed

	# get project name and set working directory to top of project
	project_name = os.path.split(path)[-1]
	os.chdir(path)

	# set initial param values for project's context
	P.setup(project_name)

	# import params defined in project's local params file in ExpAssets/Config
	for k, v in imp.load_source("*", P.params_file_path).__dict__.iteritems():
		setattr(P, k, v)

	KLDatabase(project_name).export(multi_file, join_tables)


def rebuild_db(path):
	from klibs import P
	from klibs.KLDatabase import Database
	from klibs.KLUtilities import force_quit

	if path[-1] == "/": path = path[:-1]  # strip trailing slash from provided path if needed

	# get project name and set working directory to top of project
	project_name = os.path.split(path)[-1]
	os.chdir(path)

	# set initial param values for project's context
	P.setup(project_name)

	# import params defined in project's local params file in ExpAssets/Config
	for k, v in imp.load_source("*", P.params_file_path).__dict__.iteritems():
		setattr(P, k, v)
	Database(project_name).rebuild()
	force_quit()


# def rename(path): todo: write this, it's irritatingly complex but also super necessary



def hard_reset(path):
	from klibs.KLUtilities import iterable
	#todo: require confirmation
	for d in ['Data', 'EDF', '.versions', ('Local', 'logs')]:
		if iterable(d):
			d = join(*d)
		try:
			shutil.rmtree(join(path, "ExpAssets", d))
		except OSError:
			pass
	os.makedirs(join(path, "ExpAssets", "Data", "incomplete"))
	os.makedirs(join(path, "ExpAssets", "EDF", "incomplete"))
	os.mkdir(join(path, "ExpAssets", ".versions"))
	rebuild_db(path)


parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers(title='subcommands',
								   description='Valid arguments: create, update, run, export, hard-reset, db-rebuild',
								   help='additional help')

create_parser = subparsers.add_parser('create')
create_parser.add_argument('name', type=str)
create_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
						   help='Path where new project should be created; if empty, project will attempt to be created in current working directory.')
create_parser.set_defaults(func=create)

update_parser = subparsers.add_parser('update')
update_parser.set_defaults(func=update)

rebuild_parser = subparsers.add_parser('db-rebuild')
rebuild_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
							help='Path to directory containing the KLIBs project. Parent folder must be the project name.')
rebuild_parser.set_defaults(func=rebuild_db)

rebuild_parser = subparsers.add_parser('hard-reset')
rebuild_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
							help='Path to directory containing the KLIBs project. Parent folder must be the project name.')
rebuild_parser.set_defaults(func=hard_reset)

run_parser = subparsers.add_parser('run')
run_parser.add_argument('screen_size', type=int,
						help='The diagonal size of the screen in inches on which the experiment is being run. This is used to calculate degrees of visual angle.')
run_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
						help='Path to directory containing the KLIBs project. Parent folder must be the project name.')
run_parser.add_argument('-rs', '--random_seed', type=int,
						help="Providing a random seed will allow an experiment to continue from it's previously completed state.")
run_parser.add_argument('-d', '--development_mode', action="store_true",
						help="Development mode turns off demographics collection and turns on several debugging features.")
run_parser.add_argument('-ELx', '--no_eyelink', action="store_false",
						help="Signals the absence of a connected eyelink unit. Does nothing for non-eyetracking experiments.")
run_parser.add_argument('-dbg', '--show_debug_pane', action="store_true",
						help="Debug log will be blit to translucent panel on screen in real time.")
# todo: verbose mode should accept a value, and then logging should be incrementally verbose
run_parser.add_argument('-v', '--verbose', action="store_true",
						help="EventsInterface will syndicate EyeLink, log & LabJack messages to terminal.")
run_parser.set_defaults(func=run)

export_parser = subparsers.add_parser('export')
export_parser.add_argument('path', default=os.getcwd(), nargs="?", type=str,
						   help='Path to directory containing the KLIBs project. Parent folder must be the project name.')
export_parser.add_argument('-mf', '--multi_file', action="store_false",
						   help='Export participants as a single file or multiple files. Default is multi-file. ')
export_parser.add_argument('-j', '--join_tables', default=[], nargs="*", type=str,
						   help="Additional tables to be joined to the data output. Only 'participant' and 'data' tables are exported by default.")
export_parser.set_defaults(func=export)

args = vars(parser.parse_args())


arg_dict = {}
for key in args:
	if key != "func": arg_dict[key] = args[key]

args["func"](**arg_dict)
